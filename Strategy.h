/******************************************************** *	Strategy.h : 策略接口文件                           * *	张永锋                                              * *	zhangyf07@gmail.com                                 * *	2014.5                                              * *********************************************************/#ifndef STRATEGY_H_#define	STRATEGY_H_#include "Point.h"#include <vector>#include <cmath>extern "C" Point* getPoint(const int M, const int N, const int* top, const int* _board,                           const int lastX, const int lastY, const int noX, const int noY);extern "C" void clearPoint(Point* p);void clearArray(int M, int N, int** board);/*	添加你自己的辅助函数 */int _M, _N, _noX, _noY;double coefficient = 0.8;enum GameState {PLAYING, MACHINE_WIN, USER_WIN, TIE};struct State {    Point action;    bool machineTurn;    int** board;    std::vector<Point> actions;        State(int** board = nullptr) {        this->board = board;        actions = findActions();    }        //    ~State() {    //        if (board != nullptr) {    //            clearArray(_M, _N, board);    //        }    //    }        std::vector<Point> findActions() {        std::vector<Point> actions;        if (board == nullptr) {            return actions;        }        for (int y = 0; y< _N; y++) {            Point act;            act.y = y;            for (int x = _M-1; x >=0; x--) {                if (board[x][y] == 0) {                    act.x = x;                    break;                }            }                        if (act.y == _noY && act.x==_noX) {                act.x -= 1;            }                        if (act.x >= 0 && act.x < _M && act.y >=0 && act.y < _N && board[act.x][act.y] == 0) {                actions.push_back(act);            }        }        return actions;    }        State performAction(Point act) {        int** newBoard = new int*[_M];        for (int i = 0; i < _N; i++) {            newBoard[i] = new int[_N];            memcpy(newBoard[i], board[i], sizeof(int) * _N);        }                newBoard[act.x][act.y] = machineTurn ? 2 : 1;                State newState(newBoard);        newState.action = act;        newState.machineTurn = !machineTurn;        return newState;    }        GameState gameState();    bool isTerminal();};struct Node {    Node* parent;    std::vector<Node*> children;    State state;    double q;    double n;        Node(Node* parent=nullptr, State state=State()) {        this->parent = parent;        this->state = state;        this->q = 0;        this->n = 1;    }    };Point getUctPoint(int** _board, int lastX, int lastY);Point uctSearch(State s);Node* treePolicy(Node* v);Node* expand(Node* v);Node* bestChild(Node* v, double c);double defaultPolicy(State s);void backup(Node* v, double delta);#endif